from flask import Flask, render_template, redirect,url_for, request, session
import mysql.connector
from flask_socketio import SocketIO,join_room,leave_room,send,emit
from string import ascii_uppercase
from datetime import timedelta
import random, json
import yaml

from flask_mysqldb import MySQL

from __init__ import createApp, createSio
from game import  handle_ready,setUpData,handle_fire

#creating flask app
application = createApp()
#creating SocketIO object
sio = createSio(application)
#setting the session lifetime to one minute
application.permanent_session_lifetime = timedelta(minutes=1)

#contains every room ID generated by generateCode() and maps them to a dict containing the number of members in the room and request.sid of the first player
rooms = {}
#list of all the request.sid that are in singleplayer mode
singleplayers = []

# Configure db
db = yaml.load(open('db.yaml'), Loader=yaml.SafeLoader)
application.config['MYSQL_HOST'] = db['mysql_host']
application.config['MYSQL_USER'] = db['mysql_user']
application.config['MYSQL_PASSWORD'] = db['mysql_password']
application.config['MYSQL_DB'] = db['mysql_db']

def open_db_connection():
    try:
        connection = mysql.connector.connect(
            host='your_host',
            user='your_username',
            password='your_password',
            database='your_database'
        )
        print("Connected to MySQL database successfully!")
        return connection
    except mysql.connector.Error as error:
        print("Failed to connect to MySQL database:", error)
        return None

def close_db_connection(connection):
    if connection:
        connection.close()
        print("Connection to MySQL database closed.")
   
#generates a random room ID based on length parameter
def generateCode(length):
    while True:
        code = "" #initialize code with empty string
        for x in range(length):
            code += random.choice(ascii_uppercase)
        if code not in rooms:
            break
    return code

@application.route("/", methods=["POST","GET"])
def home():
    return render_template("menu.html")

@application.route("/singleplayer")
def singlePlayer():
    return render_template("index.html")


@application.route("/room", methods=["POST","GET"])
def room():
    session.clear()
    if request.method == "POST":
        name = request.form.get("name")
        code = request.form.get("code")
        join = request.form.get("join", False) #The second argument of get() is the default value to be returned if the "join" field does not exist in the form data. In this case, if the "join" field is not present, the variable join will be set to False.
        create = request.form.get("create", False) 

        #if no name was entered
        if not name:
            return render_template("room.html", error="Please enter a name.", code = code, name = name)
        #if Join was hit but no game ID was entered
        if join != False and not code:
            return render_template("room.html", error="Please enter a Room ID.", code = code, name = name)
        
        room = code
        if create != False: #create new room if they press create button and name is entered
            room = generateCode(5)
            rooms[room] = {"members":0} #initially set the members in the room to 0 until the players connect using the object in index.html
        elif code not in rooms: #if they are joining the room but their session ID is not valid
            return render_template("room.html", error="Room ID does not exist", code = code, name = name)
        if join != False and rooms[room]['members']>=2: #if room already has 2 players in it it avoids connection and goes back to room.html
            print("FROM ROOM: " + str(rooms[room]['members']))
            return render_template("room.html", error="This Room already has 2 players")
        #store the room and name in the session assicoiated with the client
        session["room"] = room
        session["name"] = name
        #load the game 
        return redirect(url_for("game"))
    else:
        return render_template("room.html")

@application.route("/game")
def game():
    room = session.get("room") #get the room ID associated with client
    if room is None or session.get("name") is None or room not in rooms: #if not valid return to room
        return redirect(url_for("room")) 
    
    return render_template("index.html") 

@sio.on("connect")
def connect(auth):
    room = session.get("room")
    name = session.get("name")
    #if room and name dont exist append the request.sid to singleplayers list
    if not room or not name:
        singleplayers.append(request.sid)
        return
    #if the room does not exist leave the room
    if room not in rooms:
        leave_room(room)
        return
    else:
        join_room(room)

    #when first player joins set the ID to their request.sid
    if rooms[room]["members"] == 0:
        rooms[room]["ID"] = request.sid
    #when second player joins set up the data
    if rooms[room]["members"] == 1:
        setUpData(request.sid,rooms,room,name)

    rooms[room]["members"] += 1 #incrementing the members in a room after a player has successfully joined
    emit('gameinfo_message', "your game ID is: " + room, to=request.sid)
   

@sio.on("disconnect")
def disconnect():
    #is its multiplayer leave the room, remove the room if no player is present in it
    if request.sid not in singleplayers:
        room = session.get("room")
        name = session.get("name")
        leave_room(room)
        
        #if room is empty remove it
        if room in rooms:
            rooms[room]["members"] -= 1 #decrement the members of the room
            if rooms[room]["members"] <=0:
                del rooms[room]
    #if single player, remove the sid from the singleplayer list
    else:
        singleplayers.remove(request.sid)
#when ready button is presed, handle the matrix coming from the client
@sio.on("ready")
def ready(convertedMatrix):
    handle_ready(request.sid,convertedMatrix)   
#when a cell is clicked, handle the cell
@sio.on('fire')
def fire(hitcell):
    handle_fire(request.sid,hitcell)

if __name__ == "__main__":
    sio.run(application, debug = True)

#FINAL