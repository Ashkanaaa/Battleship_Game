from flask import Flask, render_template, redirect,url_for, request, session, jsonify, abort
import jwt
import mysql.connector
from flask_socketio import SocketIO,join_room,leave_room,send,emit
from string import ascii_uppercase
from datetime import timedelta
import random, json
import yaml
import datetime
import pytz
import secrets
from flask_mysqldb import MySQL

from __init__ import createApp, createSio
from game import  handle_ready,setUpData,handle_fire
from db.dbManager import dbManager

#creating flask app
application = createApp()
#creating SocketIO object
sio = createSio(application)
#setting the session lifetime to one minute
application.permanent_session_lifetime = timedelta(hours=1)

#contains every room ID generated by generateCode() and maps them to a dict containing the number of members in the room and request.sid of the first player
rooms = {}
#list of all the request.sid that are in singleplayer mode
singleplayers = []

# Configure db
dbConfig = yaml.load(open('db/dbConfig.yaml'), Loader=yaml.SafeLoader)

def create_db_manager():
    return dbManager(dbConfig['mysql_host'], dbConfig['mysql_user'], dbConfig['mysql_password'], dbConfig['mysql_db'])

#generates a random room ID based on length parameter
def generateCode(length):
    while True:
        code = "" #initialize code with empty string
        for x in range(length):
            code += random.choice(ascii_uppercase)
        if code not in rooms:
            break
    return code

def generateToken(username, db_manager):
    exp_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(hours=1)
    print('EXP TIMEEEE:' + str(exp_time))

    #expiration_time = datetime.datetime.fromtimestamp(int(exp_time))
    payload = {
                'user_id': db_manager.get_user_id(username),
                'exp': exp_time,
                'type': 'Access'
            }
    return jwt.encode(payload, application.config['SECRET_KEY'], algorithm='HS256')

def generateRefreshToken(userId):
    exp_time = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=1)
    print('EXP TIMEEEE:' + str(exp_time))

    #expiration_time = datetime.datetime.fromtimestamp(int(exp_time))
    payload = {
                'user_id': userId,
                'exp': exp_time,
                'type': 'Refresh'
            }
    return jwt.encode(payload, application.config['SECRET_KEY'], algorithm='HS256')

def decode_token(token):
    decoded_token = jwt.decode(token, application.config['SECRET_KEY'], algorithms=['HS256'])
    return decoded_token

##########################################################################

@application.route("/", methods=["POST","GET"])
def home():
    return render_template('login.html')

@application.route('/token/refresh', methods=['POST', 'GET'])
def refresh_token():
    auth_header = request.headers.get('Authorization')
    try:
        refresh_token = decode_token(auth_header.split(" ")[1])
    except jwt.ExpiredSignatureError:
        print('looks like expired')
        return jsonify({'message': 'Token has expired'}), 401
    except jwt.InvalidTokenError:
        return jsonify({'message': 'Invalid token'}), 401
    
    if refresh_token.get('type') == 'Refresh':
        print('GOT TO THIS STEP')
        db_manager = create_db_manager()
        token = generateToken(db_manager.get_username(refresh_token.get('user_id')), db_manager)
        new_refresh_token = generateRefreshToken(refresh_token.get('user_id'))
        return jsonify({'token': token, 'refreshToken': new_refresh_token, 'message': 'New access and refresh token successfully generated!'}), 200
    else:
        return jsonify({'message': 'Invalid refresh token!'}), 401

@application.route('/login', methods=["POST", "GET"])
def login():
    if request.method == "POST":
        data = request.get_json()
        username = data.get('username')
        password = data.get('password')
        
        db_manager = create_db_manager()

        if db_manager.validate_login(username, password):
            token = generateToken(username, db_manager)
            refresh_token = generateRefreshToken(db_manager.get_user_id(username))
            print('BACKEND TOKEN:' + token)
             # Return the token as part of a JSON response
            return jsonify({'token': token, 'refreshToken': refresh_token, 'message': 'Successful Login!'}), 200
        elif db_manager.username_exists(username):
            print('INVALID USERRRRRRRRR HEREE')
            return jsonify({'token': None, 'message': 'The password is invalid or the username already exists'}), 401
        else:
            print("CREATED A NEW USER")
            db_manager.create_new_user(username, password)
            return jsonify({'token': None, 'message': 'Your new account has been created, login with your credentials!'}), 201
    else:
        return render_template('login.html')

@application.route('/main-menu', methods=['POST', 'GET'])
def main_menu():
    return render_template('menu.html')

@application.route("/singleplayer")
def singlePlayer():
    return render_template("index.html")

@application.route("/room", methods=["POST","GET"])
def room():
    session.clear()
    if request.method == 'POST':
        data = request.get_json()
        auth_header = request.headers.get('Authorization')
        token = None
        try:
            token = decode_token(auth_header.split(" ")[1])
        except jwt.ExpiredSignatureError:
            print('looks like expired')
            print (token)
            return jsonify({'message': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token'}), 401
        
        if token.get('type') != 'Access':
            return  jsonify({'message': 'Refresh token cant be used for accessing this resource'}), 401

        room = data.get('code') if 'code' in data else None
        
        if not room: #create new room if they press create button and name is entered
            print('CREATED A NEW ROOM')
            room = generateCode(5)
            rooms[room] = {"members":0} #initially set the members in the room to 0 until the players connect using the object in index.html
        elif room not in rooms: #if they are joining the room but their session ID is not valid
            print('CODE NOT IN ROOMS')
            return jsonify({'message': 'Room ID does not exist'}), 404
        if room and rooms[room]['members']>=2: #if room already has 2 players in it it avoids connection and goes back to room.html
            print("FROM ROOM: " + str(rooms[room]['members']))
            return jsonify({'message': 'This room already has 2 players'}), 403
        #store the room and name in the session assicoiated with the client
        db_manager = create_db_manager()
        session['room'] = room
        session['user_id'] = token.get('user_id')
        session['name'] = db_manager.get_username(token.get('user_id'))
        #load the game 
        return jsonify({'redirect': url_for('game')}), 200
    else:
        return render_template("room.html")

@application.route('/single-player-result', methods=['POST'])
def single_player_result():
    if request.method == 'POST':
        auth_header = request.headers.get('Authorization')
        token = None
        try:
            token = decode_token(auth_header.split(" ")[1])
        except jwt.ExpiredSignatureError:
            print('looks like expired')
            return jsonify({'message': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token'}), 401
        
        if token.get('type') != 'Access':
            return jsonify({'message': 'Refresh token cant be used for accessing this resource'}), 401
        
        user_id = token.get('user_id')
        result = request.args.get('result')
        db_manager = create_db_manager()
        if db_manager.update_game_result(user_id, None, result):
            return jsonify({'message': 'The DB has been successfully updated with the results'}), 200
        else:
            return jsonify({'message': 'Failed to update the DB with the results'}), 500
    else:
        return jsonify({'error': 'Method Not Allowed'}), 405

@application.route('/stats', methods=['POST', 'GET'])
def stats():
    if request.method == 'POST':
        auth_header = request.headers.get('Authorization')
        token = None
        try:
            token = decode_token(auth_header.split(" ")[1])
        except jwt.ExpiredSignatureError:
            print('looks like expired')
            return jsonify({'message': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token'}), 401
        
        if token.get('type') != 'Access':
            return jsonify({'message': 'Refresh token cant be used for accessing this resource'}), 401 
         
        user_id = token.get('user_id')
        db_manager = create_db_manager()
        player_stat = db_manager.get_player_stat(user_id)
        game_stats = db_manager.get_game_stats(user_id)

        if player_stat and game_stats:
            data = {
                'game_stats': game_stats,
                'player_stat': player_stat
            }
            return jsonify({'message': 'Stats were successfully retrieved', 'stats': data}), 200
        else:
            return jsonify({'message': 'Failed to retrieve the stats', 'stats': {}}), 500
    else:
        return render_template('stats.html')

@application.route("/game")
def game():
    room = session.get('room') #get the room ID associated with client
    if room is None or session.get("name") is None or room not in rooms: #if not valid return to room
        print('ROOM IS NOT VALID')
        return redirect(url_for("room")) 
    return render_template("index.html") 

@sio.on("connect")
def connect(auth):
    room = session.get('room')
    name = session.get('name')
    user_id = session.get('user_id')

    # If room and name dont exist append the request.sid to singleplayers list
    if not room or not name:
        singleplayers.append(request.sid)
        return
    # If the room does not exist leave the room
    if room not in rooms:
        leave_room(room)
        return
    else:
        join_room(room)

    # When first player joins set the enemy_sid to their request.sid
    if rooms[room]["members"] == 0:
        rooms[room]["enemy_sid"] = request.sid
        rooms[room]['enemy_user_id'] = user_id
    # When second player joins set up the data
    if rooms[room]["members"] == 1:
        setUpData(request.sid,rooms,room,name, user_id)

    rooms[room]["members"] += 1 #incrementing the members in a room after a player has successfully joined
    emit('gameinfo_message', "your game ID is: " + room, to=request.sid)
   

@sio.on("disconnect")
def disconnect():
    #is its multiplayer leave the room, remove the room if no player is present in it
    if request.sid not in singleplayers:
        room = session.get("room")
        name = session.get("name")
        leave_room(room)
        
        #if room is empty remove it
        if room in rooms:
            rooms[room]["members"] -= 1 #decrement the members of the room
            if rooms[room]["members"] <=0:
                del rooms[room]
    #if single player, remove the sid from the singleplayer list
    else:
        singleplayers.remove(request.sid)
#when ready button is presed, handle the matrix coming from the client
@sio.on("ready")
def ready(convertedMatrix):
    handle_ready(request.sid,convertedMatrix)   
#when a cell is clicked, handle the cell
@sio.on('fire')
def fire(hitcell):
    handle_fire(request.sid,hitcell)

if __name__ == "__main__":
    sio.run(application, debug = True)

#FINAL